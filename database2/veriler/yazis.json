[
    {"_id":"2cb9bb7ab9acda2d6cf92b31","baslik":"PHP 8.0 nelerle geliyor?","url":"php-8.0-nelerle-geliyor","icerik":"<p>Bu yazıda PHP 8.0 hakkında kesinleşen ve tartışılan yeni &ouml;zellikler hakkında bilgiler vereceğim. PHP 7.0&rsquo;ın &ccedil;ıkışı &ouml;zellikle performans iyileştirmeleriyle dikkatleri &uuml;zerine &ccedil;ekmiş, ve hatta Facebook&rsquo;un yayınladığı performans odaklı HHVM isimli PHP motoruna olan talebi de azaltmıştı. PHP 8.0 da en az PHP 7.0 kadar konuşulacak yeni &ouml;zelliklerle geliyor.<\/p>\r\n\r\n<p>PHP8&rsquo;de beklenen en b&uuml;y&uuml;k yenilik JIT derlemesi. Yaklaşık iki ay &ouml;nce, PHP&rsquo;nin JIT&nbsp;<a href=\"https:\/\/wiki.php.net\/rfc\/jit\" rel=\"nofollow\" target=\"_blank\">taslağı<\/a>, PHP geliştiricileri tarafından oylandı ve kabul edildi. Buna g&ouml;re PHP8&rsquo;e JIT&rsquo;in uygulanacak olması kesinleşti. PHP&rsquo;nin geliştiricisi Zend firması, halihazırda PHP8&rsquo;e ve yeni JIT motorununun geliştirmesine başladı bile.<\/p>\r\n\r\n<p>Şimdi bu yeni JIT &ouml;zelliğinden bahsedelim. JIT, bazı programlama dillerinde de kullanılan bir &ccedil;alıştırma y&ouml;ntemidir. Normalde PHP&rsquo;nin mevcut (mesela 7.0) s&uuml;r&uuml;m&uuml;n&uuml;n bir yorumlayıcı programı olur ve verilen kaynak kodunu okuduktan sonra bunu PHP motorunun anlayabileceği bir bytecode&rsquo;a &ccedil;evirir ardından bunu da yorumlayarak &ccedil;ıktısını verir. Ancak JIT ile her defasında aynı işlemin yapılması yerine, yorumlanması i&ccedil;in oluşturulmuş olan mevcut bytecode&rsquo;u Assembly&rsquo;e yani işlemcinin anlayacağı dile &ccedil;evirir ve kaynak kodun tekrar okunmasına gerek duyulmadığı s&uuml;re boyunca aynı makine kodunun &ccedil;ıktısını vermeye devam eder. Bu sayede bir kodun yorumlanması i&ccedil;in gereken bu s&uuml;re&ccedil; i&ccedil;erisinde t&uuml;ketilen sistem kaynaklarından tasarruf edilmiş olur ve tabiki kodun &ccedil;alışma s&uuml;resi azaltılır.<\/p>\r\n\r\n<p>PHP&rsquo;nin temellerini atan iki geliştiriciden biri olan Zeev Suraski, PHP 7.0 ile PHP 8.0&rsquo;ın bir karşılaştırmasını yaptığı video hazırlamış. Buradan ikisi arasındaki performansı daha iyi anlayabilirsiniz.<\/p>\r\n\r\n<p><iframe frameborder=\"0\" height=\"315\" src=\"https:\/\/www.youtube-nocookie.com\/embed\/dWH65pmnsrI\" width=\"560\"><\/iframe><\/p>\r\n\r\n<p>PHP 8.0&rsquo;a JIT dışında beklenen yeni deprecation&rsquo;lar ve d&uuml;zenlemeler şunlar:<\/p>\r\n\r\n<ul>\r\n\t<li>G&uuml;n&uuml;m&uuml;zde pek fazla kullanılmayan &ouml;zellik olan PHP short tags (kısa PHP etiketleri), PHP 8.0 ile birlikte tamamen kaldırılacak.<\/li>\r\n\t<li>&Uuml;&ccedil;l&uuml; karşılaştırma operat&ouml;rlerinden (ifade ? bir : iki) parantezsiz olarak fazladan ifade eklenimi kaldırılacak.&nbsp;<code>ifade ? bir : iki ? &uuml;&ccedil; : d&ouml;rt<\/code>&nbsp;yerine yalnızca parantezli kullanımına izin verilecek&nbsp;<code>ifade ? bir : (iki ? &uuml;&ccedil; : d&ouml;rt)<\/code>; bu sayede olası yanlış anlaşılmaların &ouml;n&uuml;ne ge&ccedil;ilecek ve kodun okunabilirliği artacak.<\/li>\r\n\t<li>Kullanıcı fonksiyonlarındaki&nbsp;<code>TypeError<\/code>, dahili fonksiyonlar i&ccedil;in de ge&ccedil;erli olacak. Daha &ouml;nce dahili fonksiyonlarından t&uuml;r hatası yerine null ya da sadece uyarı mesajı d&ouml;nd&uuml;r&uuml;l&uuml;yordu.<\/li>\r\n\t<li>Birleşme operat&ouml;r&uuml;n&uuml;n &ouml;nceliği değiştiriliyor. Mevcut davranışta soldan sağa iken, yeni davranışında toplama ve &ccedil;ıkarma işlemi daha y&uuml;ksek &ouml;nceliğe sahip olacak. &Ouml;rneğin&nbsp;<code>&quot;3&quot; . &quot;5&quot; + 7<\/code>&nbsp;ifadesi&nbsp;<code>42<\/code>&nbsp;yerine&nbsp;<code>&quot;312&quot;<\/code>&nbsp;değerine eşit olacak.<\/li>\r\n\t<li>Birden fazla t&uuml;r belirtimi desteği (Union Types) gelecek. &Ouml;rneğin bir class i&ccedil;erisinde&nbsp;<code>int $number<\/code>&nbsp;tanımladığımızı varsaydığımız değişkeni isterseniz&nbsp;<code>int|float $number<\/code>&nbsp;olarak da tanımlayabilirsiniz. B&ouml;ylece bu değişkene hem&nbsp;<code>int<\/code>&nbsp;hem&nbsp;<code>float<\/code>&nbsp;t&uuml;r&uuml;nde değer tanımlanabilir.<\/li>\r\n\t<li>Diziler (array) negatif index ile başlatılabilecek. &Ouml;rneğin:&nbsp;<code>$coord[-4] = ...<\/code><\/li>\r\n<\/ul>\r\n\r\n<p>PHP&rsquo;nin gelişimi s&uuml;rd&uuml;k&ccedil;e, PHP 8.0 i&ccedil;in planlanan yeni &ouml;zellikler tartışılmaya ve &ccedil;ıkartılmaya başlanacaktır. &Ccedil;ıkış tarihi hen&uuml;z kesinleşmiş olmasa da 2021&rsquo;den &ouml;nce &ccedil;ıkmayacağı a&ccedil;ıklandı. Yeni gelişmeler olduk&ccedil;a yazıyı g&uuml;ncellemeye devam edeceğim. Şimdilik bu kadar.<\/p>","kategori":"1cb9bb7ab9acda2d6cf92b31","tarih":"2020-01-13 15:04:37", "oneCikarilan": "0", "etiketler":"a,b"},
    {"_id":"2cb9bb7ab9acda2d6cf92b32","baslik":"Temiz Kod Yazımı","url":"temiz_kod_yazimi","icerik":"<h3><strong>Mantıklı ve anlamlı değişken isimleri kullanın.<\/strong><\/h3>\r\n\r\n<pre>\r\n<code class=\"language-php\">$ymdstr = $moment-&gt;format('y-m-d');<\/code><\/pre>\r\n\r\n<p>yerine,<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$currentDate = $moment-&gt;format('y-m-d');<\/code><\/pre>\r\n\r\n<h3><strong>Aynı değişken t&uuml;rleri i&ccedil;in aynı kelime hazinesi kullanın.<\/strong><\/h3>\r\n\r\n<pre>\r\n<code class=\"language-php\">getUserInfo();\r\ngetUserData();\r\ngetUserRecord();\r\ngetUserProfile();<\/code><\/pre>\r\n\r\n<ol>\r\n<\/ol>\r\n\r\n<p>yerine,<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">getUser();<\/code><\/pre>\r\n\r\n<h3><strong>Aranabilen isimler kullanın.<\/strong><\/h3>\r\n\r\n<pre>\r\n<code class=\"language-php\">$result = $serializer-&gt;serialize($data, 448); \/\/ What the heck is 448 for?<\/code><\/pre>\r\n\r\n<p>yerine,<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);<\/code><\/pre>\r\n\r\n<p>-----<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">if ($user-&gt;access &amp; 4) {\r\n    \/\/ What the heck is 4 for?\r\n}<\/code><\/pre>\r\n\r\n<p>yerine,<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">class User{\r\n    const ACCESS_READ = 1;\r\n    const ACCESS_CREATE = 2;\r\n    const ACCESS_UPDATE = 4;\r\n    const ACCESS_DELETE = 8;\r\n}\r\nif ($user-&gt;access &amp; User::ACCESS_UPDATE) {\r\n    \/\/ do edit ...\r\n}<\/code><\/pre>\r\n\r\n<h3><strong>Gereksiz i&ccedil;erikleri ekleme.<\/strong><\/h3>\r\n\r\n<pre>\r\n<code class=\"language-php\">&lt;?php\r\nclass Car{\r\n    public $carMake;\r\n    public $carModel;\r\n    public $carColor;\r\n\r\n    \/\/...\r\n}\r\n<\/code><\/pre>\r\n\r\n<h4>yerine,<\/h4>\r\n\r\n<pre>\r\n<code class=\"language-php\">&lt;?php\r\nclass Car{\r\n    public $make;\r\n    public $model;\r\n    public $color;\r\n\r\n    \/\/...\r\n}\r\n<\/code><\/pre>\r\n\r\n<h3><strong>2 veya daha az fonksiyon parametresi kullanın.<\/strong><\/h3>\r\n\r\n<pre>\r\n<code class=\"language-php\">&lt;?php\r\nfunction createMenu($title, $body, $buttonText, $cancellable) {\r\n    \/\/ ...\r\n}\r\n<\/code><\/pre>\r\n\r\n<h4>yerine,<\/h4>\r\n\r\n<pre>\r\n<code class=\"language-php\">&lt;?php\r\nclass MenuConfig{\r\n    public $title;\r\n    public $body;\r\n    public $buttonText;\r\n    public $cancellable = false;\r\n}\r\n\r\n$config = new MenuConfig();\r\n$config-&gt;title = 'Foo';\r\n$config-&gt;body = 'Bar';\r\n$config-&gt;buttonText = 'Baz';\r\n$config-&gt;cancellable = true;\r\n\r\nfunction createMenu(MenuConfig $config) {\r\n    \/\/ ...\r\n}\r\n<\/code><\/pre>\r\n\r\n<h3><strong>Fonksiyonalr tek birşey olmalıdır.<\/strong><\/h3>\r\n\r\n<pre>\r\n<code class=\"language-php\">&lt;?php\r\nfunction emailClients($clients) {\r\n    foreach ($clients as $client) {\r\n        $clientRecord = $db-&gt;find($client);\r\n        if ($clientRecord-&gt;isActive()) {\r\n            email($client);\r\n        }\r\n    }\r\n}\r\n<\/code><\/pre>\r\n\r\n<h4>yerine,<\/h4>\r\n\r\n<pre>\r\n<code class=\"language-php\">function emailClients($clients) {\r\n    $activeClients = activeClients($clients);\r\n    array_walk($activeClients, 'email');\r\n}\r\n\r\nfunction activeClients($clients) {\r\n    return array_filter($clients, 'isClientActive');\r\n}\r\n\r\nfunction isClientActive($client) {\r\n    $clientRecord = $db-&gt;find($client);\r\n    return $clientRecord-&gt;isActive();\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>Daha fazla detay ve i&ccedil;erik i&ccedil;in;&nbsp;<a href=\"https:\/\/github.com\/jupeter\/clean-code-php\/blob\/master\/README.md\" target=\"_blank\">clean-code<\/a><\/p>\r\n","kategori":"1cb9bb7ab9acda2d6cf92b31","tarih":"2020-01-13 15:04:37", "oneCikarilan": "0", "etiketler":"a,b,c"},
    {"_id":"2cb9bb7ab9acda2d6cf92b33","baslik":"NodeJS Nedir?","url":"nodejs-nedir","icerik":"<p>Yazdığımız uygulamalar y&uuml;ksek ihtimalle &ccedil;ok kullanıcılı uygulamalardır. &Ccedil;oklu kullanıcılı uygulamalar genelde Sunucu(Server)\/İstemci(Client) mantığı ile yazılır. Sunucu yani &ccedil;evrim i&ccedil;i &ccedil;alışan, t&uuml;m verilerin tutulduğu merkezi bir sistem. İstemci yani bu merkezi sisteme bağlı &ccedil;alışan merkezi sisteme veri iletimi yapan, kullanıcıyla etkileşimi sağlayan yan program.<\/p>\r\n\r\n<p><img alt=\"serverside-clientside\" src=\"\/upload\/files\/serverside-clientside%20(1).png\" style=\"height:260px; width:916px\" \/><\/p>\r\n\r\n<p>G&uuml;n&uuml;m&uuml;z modern uygulamalar da bu istemci genelde tarayıcıdır(browser). Tarayıcı &uuml;zerinden kullanılan uygulamalar genelde Web Uygulaması olarak adlandırılır. Kullanıcı uygulamayı kullanmak istediğinde tarayıcıdan sunucuya bir istek g&ouml;nderir, sunucu isteğe g&ouml;re uygulama i&ccedil;erisinde kendi anlayacağı b&ouml;l&uuml;mleri işleyerek kullanıcıya uygun &ccedil;ıktıyı &uuml;retir ve tarayıcıya g&ouml;nderir. Tarayıcı aldığı &ccedil;ıktıyı kendi i&ccedil;erisinde yorumlar ve kullanıcıya uygun &ccedil;ıktıyı &uuml;retir. Sonra kullanıcı gerektiği yerde tekrar sunucuya istek g&ouml;nderir, tekrar cevap gelir&hellip; Genel olarak tarayıcı bazlı Sunucu\/İstemci mimarisi basit anlatımla bu şekilde &ccedil;alışır.<\/p>\r\n\r\n<p>Burada &ouml;nemli bir kısım sunucunun kendi anladığı kısımları yani sunucu tabanlı diller(C#, Java, Php, Python, Ruby&hellip;) ile yazılmış kısımları &ccedil;alıştırması, tarayıcının da kendi anladığı yani tarayıcı dilleri(HTML,Css,Javascript, Dart&hellip; ) ile yazılmış kısımları &ccedil;alıştırmasıdır. Sunucu tarafında &ccedil;alışan koda&nbsp;<strong>Backend<\/strong>, tarayıcı &uuml;zerinde &ccedil;alışan koda&nbsp;<strong>Frontend&nbsp;<\/strong>denir. Web uygulamarı yazarken Backend ve Frontend kodları aynı proje i&ccedil;erisinde kullanırız. Hangi iş mantığı hangi kısımda &ccedil;alışacaksa ona g&ouml;re ya Backend&rsquo;de yada Frontend&rsquo;de yazılır.<\/p>\r\n\r\n<h1>Javascript<\/h1>\r\n\r\n<p>Frontend dillerinden en &ouml;nemlilerinden bir tanesi Javascript&rsquo;tir. Web tarayıcılarının etkin bir şekilde kullanılması i&ccedil;in geliştirilmiştir. Kullanıcıyla etkileşimin artırılması, iş y&uuml;k&uuml;n&uuml;n sunuculardan istemcilere taşınması, daha g&ouml;rsel animasyonlu web siteleri\/ web uygulamaları geliştirilmesi gibi kullanım alanları vardır. 1995 yıllarında &ccedil;ıktı. Java diliyle isim benzerliği dışında hi&ccedil;bir alakası yoktur. Javasvript standartları Ecma International firması tarafından ECMASCRIPT standartlarıyla belirlenir. G&uuml;n&uuml;m&uuml;zde kullanılan ECMASCRIPT standardı 5.1 s&uuml;r&uuml;m&uuml;d&uuml;r. Ve bu standart Javascript 1.8.1 ile desteklenmektedir. Ancak şu aralar ECMASCRIPT 6 standardı &uuml;zerinde &ccedil;alışmalar devam etmektedir.<\/p>\r\n\r\n<p>Javascript prototip bazlı nesne y&ouml;nelimli programlama, fonksiyonel programlama, imparatif programlama paradigmalarını destekler. Genellikle tarayıcılarda kullanılır. Google&rsquo;ın Chrome tarayıcısını ve bu tarayıcı i&ccedil;erisindeki V8 Javascript motorunu geliştirmesiyle Javascript performansında ve gelişimde b&uuml;y&uuml;k y&uuml;kselişler oldu. Bu Javascript motorunun g&uuml;c&uuml; sayesinde daha &ouml;nce yapılamayan bir&ccedil;ok uygulama yapıldı. Ve ilk defa Javascript frontend&rsquo;den &ccedil;ıkarak Backend tarafına ge&ccedil;iş yaptı ve Nodejs doğdu.<\/p>\r\n\r\n<h1>NodeJS<\/h1>\r\n\r\n<p>NodeJs 2009 yılında Joyent firmasında &ccedil;alışan Ryan Dahl tarafından geliştirilen Javascript &Ccedil;alışma Ortamıdır.(Javascript Runtime Enviroment). Joyent firmasının desteği ve V8 motorunun g&uuml;c&uuml; ile Dahl Javascript&rsquo;i Backend kısmına taşıdı.<\/p>\r\n\r\n<blockquote>\r\n<p>&ldquo;Nodejs backend tarafında &ccedil;alışan, javascript tabanlı scriptleri yorumlanabilen ve &ccedil;alıştırabilen, hızlı, &ouml;l&ccedil;eklenebilir &nbsp;network uygulamaları geliştirmeyi sağlayan bir &ccedil;alışma zamanı ortamıdır(runtime enviroment).&rdquo;<\/p>\r\n<\/blockquote>\r\n\r\n<p>Javascript&rsquo;in backend&rsquo;e(server side) taşınması ile developerlar tek dil bilerek hem frontend hem backend kod yazabilir hale geldiler. Frontend de kullanılan javascript k&uuml;t&uuml;phanelerinden bazıları backend tarafında kullanılabilir hale geldi.<\/p>\r\n\r\n<p>Javascript&rsquo;in doğal Non Block mimarisi sayesinde backend tarafında &ouml;l&ccedil;eklenebilir uygulamalar daha kolay bir şekilde yazılabilir hale geldi. Nodejs&rsquo;in &ouml;l&ccedil;eklenebilir uygulamalardaki başarısı sayesinde kullanıcı sayısı milyonlarla ifade edilen b&uuml;y&uuml;k siteler nodejs kullanmaya başladı. &Uuml;stelik bunu single thread olarak yapabiliyor.<\/p>\r\n\r\n<blockquote>\r\n<p>&ldquo;&Ouml;l&ccedil;eklenebilirlik, bir uygulamanın aynı anda birden &ccedil;ok kullanıcıya takılmadan cevap verebilir halde olmasıdır.&rdquo;<\/p>\r\n<\/blockquote>\r\n\r\n<p>Peki bunu nasıl başarıyor? Nodejs olay bazlı(event-driven) Non-Blocking yapısını Event loop denilen bir mimariyle sağlıyor. (İlerde detayına gireceğiz.) Bu mimariyle tek bir thread(single thread) ile asenkron &ccedil;alışabilmektedir.<\/p>\r\n\r\n<p>Bunların dışında Nodejs&rsquo;in en b&uuml;y&uuml;k avantajlarından bir taneside mod&uuml;ler yapısı ve bu yapıyı destekleyen paket y&ouml;netim sistemi: npm(nodejs package manager). Nodejs npm ve npm yi destekleyen topluluk sayesinde hemen hemen her işimizi paketler sayesinde halledebiliyoruz. Şuan npm &uuml;zerindeki paket sayısı yaklaşık 250000 civarında. E okadar paket i&ccedil;erisinde mutlaka işimize yarayan bir paket vardır :). Tabi bu kadar paket Nodejs&rsquo;in arkasında &ccedil;ok b&uuml;y&uuml;k bir topluluğun olduğunuda g&ouml;steriyor. Bu kadar b&uuml;y&uuml;k bir topluluğun i&ccedil;erisinde sorunları &ccedil;&ouml;zmekte kolay.<\/p>","kategori":"1cb9bb7ab9acda2d6cf92b32","tarih":"2020-01-13 15:04:37", "oneCikarilan": "0", "etiketler":"a,b,c,d"},
    {"_id":"2cb9bb7ab9acda2d6cf92b34","baslik":"PHP 7.4 İle Gelen Yenilikler","url":"php-7.4-ile-gelen-yenilikler","icerik":"<pre>\r\n<code class=\"language-ruby\">$arrayA = [1, 2, 3];\r\n\r\n$arrayB = [4, 5];\r\n\r\n$result = [0, ...$arrayA, ...$arrayB, 6 ,7];\r\n\r\n\/\/ [0, 1, 2, 3, 4, 5, 6, 7]<\/code><\/pre>\r\n\r\n<p>&nbsp;<\/p>","kategori":"1cb9bb7ab9acda2d6cf92b32","tarih":"2020-01-13 15:04:37", "oneCikarilan": "0", "etiketler":"a,b,c,d,e"},
    {"_id":"2cb9bb7ab9acda2d6cf92b35","baslik":"Laravel için 8 Timestamps İpucusu","url":"laravel-icin-8-timestamps-ipucusu","icerik":"<h2>1. Zaman Damgalarını Devre Dışı Bırak<\/h2>\r\n\r\n<p>DB tablonuzda bu alanlar yoksa ve <strong>Model::create($arrayOfValues);<\/strong> gibi bir şey yapmaya &ccedil;alışacaksınız; - SQL hatası alırsınız. Laravel, tarih\/updated_at dosyasını otomatik olarak doldurmaya &ccedil;alışır ve bulamaz. Bu otomatik zaman damgalarını devre dışı bırakmak i&ccedil;in, Mevcut Modelinizde bir property eklemeniz gerekir:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">class Role extends Model{\r\n    public $timestamps = FALSE;\r\n}<\/code><\/pre>\r\n\r\n<h2>2. Zaman Damgası S&uuml;tun Adlarını Değiştirme<\/h2>\r\n\r\n<p>Laravel olmayan bir veritabanıyla &ccedil;alışıyorsanız ve zaman damgası s&uuml;tunlarınız farklı adlandırılırsa ne olur? Belki, <strong>create_time <\/strong>ve <strong>update_time <\/strong>var. Neyse ki, bunları modelde de belirleyebilirsiniz:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">class Rol extends Model{\r\n    const tarih = 'yaratma_zamanı';\r\n    const UPDATED_AT = 'guncelleme_zamanı'; \r\n}<\/code><\/pre>\r\n\r\n<h2>3. Zaman Damgası Tarih \/ Saat Bi&ccedil;imini Değiştir<\/h2>\r\n\r\n<p>Burada sadece resmi <a href=\"https:\/\/laravel.com\/docs\/master\/eloquent-mutators#date-mutators\" rel=\"noreferrer noopener\" target=\"_blank\">Laravel<\/a>&nbsp;belgelerini alıntılayacağım: Varsayılan olarak, zaman damgaları <code>&#39;Y-m-d H:i:s&#39;<\/code> olarak bi&ccedil;imlendirilir. Zaman damgası bi&ccedil;imini &ouml;zelleştirmeniz gerekiyorsa, modelinizde <code>$dateFormat<\/code>&nbsp;&ouml;zelliğini ayarlayın. Bu &ouml;zellik, tarih &ouml;zniteliklerinin veritabanında nasıl depolanacağını ve model bir diziye veya JSON&#39;a serileştirildiğinde bi&ccedil;imlerini belirler:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">class Flight extends Model{\r\n    protected $dateFormat = 'U';\r\n}<\/code><\/pre>\r\n\r\n<h2>4. Many-to-Many: Zaman Damgalı Pivot Tablo<\/h2>\r\n\r\n<p>Zaman damgaları otomasyonu i&ccedil;in biraz istisna, <strong>users<\/strong>&nbsp;ve <strong>roles<\/strong>&nbsp;tabloları arasındaki table <strong>role_user<\/strong>&nbsp;gibi, &ccedil;ok-&ccedil;ok ilişkide bir pivot tablo oluşturduğunuzdadır. Modelde, ilişkiyi ş&ouml;yle tanımlarsınız:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">class User extends Model{\r\n    public function roles(){\r\n        return $this-&gt;belongsToMany(Role::class);\r\n    }\r\n}<\/code><\/pre>\r\n\r\n<p>Ve sonra, bir kullanıcıya rol eklemek istediğinizde, ş&ouml;yle bir şey yaparsınız:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$roleID = 1;\r\n$user-&gt;roles()-&gt;attach($roleID);<\/code><\/pre>\r\n\r\n<p>Varsayılan olarak, bu pivot tablolarda <strong>zaman damgası bulunmaz<\/strong>. Ve Laravel bu durumda oluşturulan_at \/ updated_at dosyasını doldurmaya &ccedil;alışmaz. Ancak zaman damgalarını otomatik olarak kaydetmek istiyorsanız, bunları taşıma dosyasına eklemeniz ve ardından&nbsp;<strong>-&gt;withTimestamps()<\/strong> kullanmalısınız.<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">public function roles(){\r\n    return $this-&gt;belongsToMany(Role::class)-&gt;withTimestamps();\r\n}\r\n<\/code><\/pre>\r\n\r\n<h2>5. latest() ve oldest() ile&nbsp;Order by Timestamp<\/h2>\r\n\r\n<p>Verileri zaman damgalarına g&ouml;re sıralamak i&ccedil;in iki &ldquo;shortcuts&rdquo; vardır. Onun yerine:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">User::orderBy('tarih', 'desc')-&gt;get();<\/code><\/pre>\r\n\r\n<p>&nbsp;yerine,<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">User::latest()-&gt;get();<\/code><\/pre>\r\n\r\n<p><strong>latest()<\/strong>&nbsp; &ouml;ğesi create_at tarafından artarak sıralanır.&nbsp;<strong>oldest()<\/strong>&nbsp;ise azalarak sıralanır.<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">User::oldest()-&gt;get();<\/code><\/pre>\r\n\r\n<p>Ayrıca, sıralamak i&ccedil;in başka bir s&uuml;tun belirtebilirsiniz. &Ouml;rneğin, <strong>updated_at&nbsp;<\/strong>kullanmak istiyorsanız, bunu yapabilirsiniz:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$lastUpdatedUser = User::newest('updated_at')-&gt;first();<\/code><\/pre>\r\n\r\n<h2>6. Updated_at &ouml;ğesine dokunmadan g&uuml;ncelleme<\/h2>\r\n\r\n<p>Eloquent kaydını her g&uuml;ncellediğinizde, ge&ccedil;erli zaman damgasını otomatik olarak <strong>updated_at&nbsp;<\/strong>s&uuml;tununa kaydeder ve bu harika bir &ouml;zelliktir. Ancak bazen bundan ka&ccedil;ınmak istersiniz, &ouml;rneğin bir miktar değeri arttırırsınız ve bunu &ldquo;tam kayıt g&uuml;ncellemesi&rdquo; olarak değerlendirmek istemezsiniz. Zaman damgalarını yalnızca bir kez devre dışı bırakmak i&ccedil;in:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$user = User::find(1);\r\n$user-&gt;profile_views_count = 123;\r\n$user-&gt;timestamps = false;\r\n$user-&gt;save();<\/code><\/pre>\r\n\r\n<h2>7. Touch ve Ebeveyn Touch<\/h2>\r\n\r\n<p>Son &ouml;rneğin tersine sadece&nbsp;<strong>updated_at<\/strong>&nbsp;s&uuml;tununa yeni bir değer ayarlamak ve diğerlerini değiştirmek istemeyebilirsiniz.<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$user-&gt;update(['updated_at' =&gt; now()]);<\/code><\/pre>\r\n\r\n<p>yerine,<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$user-&gt;touch();<\/code><\/pre>\r\n\r\n<p>Başka bir durum, bazen sadece mevcut Eloquent modelinin <strong>updated_at<\/strong>&nbsp;değerini ayarlamakla kalmaz, aynı zamanda relationshipe g&ouml;re <strong>parent&#39;<\/strong>tır. &Ouml;rneğin, bazı <strong>yorumlar <\/strong>g&uuml;ncellendiğinde, g&ouml;nderi kaydının da yeni <strong>updated_at<\/strong> olması gerektiğini d&uuml;ş&uuml;nmek istersiniz. Ardından, Eloquent modelinde &ldquo;parent touches&rdquo; modellerini tanımlamanız gerekir.<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">class Comment extends Model {\r\n    protected $touches = ['post'];\r\n    public function post(){\r\n        return $this-&gt;belongsTo('Post');\r\n    }\r\n}<\/code><\/pre>\r\n\r\n<h2>8. Zaman Damgası Alanları Otomatik Olarak Carbon<\/h2>\r\n\r\n<p>Son &ldquo;bonus&rdquo; ipucu daha &ccedil;ok bir &ldquo;hatırlatma&rdquo; gibi, varsayılan olarak, <strong>tarih<\/strong>&nbsp;ve <strong>updated_at<\/strong>&nbsp;hem Eloquent modelinin <strong>$dates<\/strong>&nbsp;olarak yayınlanır, b&ouml;ylece Carbon &ouml;rneğine d&ouml;n&uuml;şt&uuml;rmeden Karbon işlemlerini ger&ccedil;ekleştirebilirsiniz. &Ouml;rneğin:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">$user-&gt;tarih-&gt;addDays(3);\r\nnow()-&gt;diffInDays($user-&gt;updated_at);<\/code><\/pre>","kategori":"1cb9bb7ab9acda2d6cf92b33","tarih":"2020-01-13 15:04:38", "oneCikarilan": "0", "etiketler":"a,b,c,d,e,f"},
    {"_id":"2cb9bb7ab9acda2d6cf92b36","baslik":"Laravel Adlandırma Kuralları","url":"laravel-adlandirma-kurallari","icerik":"<p>Laravel her g&uuml;n binlerce geliştirici tarafından her t&uuml;rl&uuml; web sitesi ve uygulama oluşturmak i&ccedil;in kullanılıyor. Ancak neyse ki, Laravel projesinin değişkenlerini, y&ouml;ntemlerini ve işlevlerini adlandırırken bir&ccedil;ok geliştirici tarafından takip edilen &ccedil;ok yaygın kullanılan bazı adlandırma kuralları vardır. İşte Laravel i&ccedil;in en iyi adlandırma kuralları;<\/p>\r\n\r\n<h2>Controller Adlandırması<\/h2>\r\n\r\n<p>Controller tekil durumda olmalı, kelimeler arasında boşluk olmamalı ve &quot;Controller&quot; ile bitmelidir. Ayrıca, her kelimenin b&uuml;y&uuml;k harflerle yazılması gerekir (blogcontroller değil, BlogController).<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>BlogController<\/code>, <code>AuthController<\/code>, <code>UserController<\/code>.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>UsersController<\/code>&nbsp;(&ccedil;oğul olduğu i&ccedil;in), <code>Users<\/code>&nbsp; (Denetleyici son eki eksik olduğu i&ccedil;in).<\/p>\r\n\r\n<h2>Veritabanı tablolarını adlandırma<\/h2>\r\n\r\n<p>DB tabloları k&uuml;&ccedil;&uuml;k harflerle, kelimeleri ayırmak i&ccedil;in alt &ccedil;izgi ile (snake_case) ve &ccedil;oğul bi&ccedil;imde olmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>posts<\/code>, <code>project_tasks<\/code>, <code>uploaded_images<\/code>.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>all_posts<\/code>,&nbsp;<code>Posts<\/code>,&nbsp;<code>post<\/code>,&nbsp;<code>blogPosts<\/code><\/p>\r\n\r\n<h2>Pivot tablolar<\/h2>\r\n\r\n<p>Pivot tabloların t&uuml;m&uuml; k&uuml;&ccedil;&uuml;k harf olmalı, her model alfabetik sırayla, alt &ccedil;izgi ile ayrılmış olmalıdır (snake_case).<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>post_user<\/code>, <code>task_user<\/code>&nbsp;vb.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>users_posts<\/code>, <code>UsersPosts<\/code>.<\/p>\r\n\r\n<h2>Tablo s&uuml;tunlarının adları<\/h2>\r\n\r\n<p>Tablo s&uuml;tunu adları k&uuml;&ccedil;&uuml;k harf ve yılan_kolu (kelimeler arasında alt &ccedil;izgi) olmalıdır. Tablo adına başvurmamalısınız.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>post_body<\/code>, <code>id<\/code>, <code>tarih<\/code>.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>blog_post_tarih<\/code>, <code>forum_thread_title<\/code>, <code>threadTitle<\/code>.<\/p>\r\n\r\n<h2>Birincil anahtar<\/h2>\r\n\r\n<p>Bu normalde <code>id&nbsp;<\/code>olmalıdır.<\/p>\r\n\r\n<h2>Yabancı anahtarlar<\/h2>\r\n\r\n<p>Yabancı anahtarlar model adı (tekil) olmalı ve buna &#39;_id&#39; eklenmiş olmalıdır (diğer tablodaki PK&#39;nin &#39;id&#39; olduğu varsayılarak).<\/p>\r\n\r\n<p>&Ouml;rneğin:&nbsp;&nbsp;<code>comment_id<\/code>,&nbsp;<code>user_id<\/code><\/p>\r\n\r\n<h2>Değişkenler<\/h2>\r\n\r\n<p>Normal değişkenler genellikle ilk karakter k&uuml;&ccedil;&uuml;k harf olacak şekilde olmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>$users = ...<\/code>,&nbsp;<code>$bannedUsers = ...<\/code>.&nbsp;<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>$all_banned_users = ...<\/code>,&nbsp;<code>$Users=...<\/code>.<\/p>\r\n\r\n<p>Değişken, bir dizi veya birden &ccedil;ok &ouml;ğe koleksiyonu i&ccedil;eriyorsa, değişken adı &ccedil;oğul olmalıdır. Aksi takdirde, tekil formda olmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>$users = User::all();<\/code> (bu birden &ccedil;ok Kullanıcı nesnesinin bir koleksiyonu olacağı i&ccedil;in), ancak <code>$user = User::first()<\/code> (bu yalnızca bir nesne olduğu i&ccedil;in)<\/p>\r\n\r\n<h2>Modeller i&ccedil;in Adlandırma Kuralları<\/h2>\r\n\r\n<p>Bir model tekil olmalı, kelimeler arasında boşluk olmamalı ve b&uuml;y&uuml;k harf kullanılmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>User<\/code>&nbsp;(\\App\\User or \\App\\Models\\User, etc),&nbsp;<code>ForumThread<\/code>,&nbsp;<code>Comment<\/code>.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>Users<\/code>,&nbsp;<code>ForumPosts<\/code>,&nbsp;<code>blogpost<\/code>,&nbsp;<code>blog_post<\/code>,&nbsp;<code>Blog_posts<\/code>.<br \/>\r\nGenel olarak, modelleriniz aşağıdaki y&ouml;ntemle hangi veritabanı tablosunu kullanması gerektiğini otomatik olarak &ccedil;&ouml;zebilmelidir:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">\/**\r\n  * Get the table associated with the model.\r\n  * @return string\r\n*\/\r\npublic function getTable(){\r\n   if(! isset($this-&gt;table)) {\r\n       return str_replace('\\\\', '', Str::snake(Str::plural(class_basename($this))));\r\n   }\r\n   return $this-&gt;table;\r\n}<\/code><\/pre>\r\n\r\n<p>Ancak elbette, modelinizde <code>$this-&gt;table <\/code>olarak ayarlayabilirsiniz.&nbsp;<code>php artisan make:model -m ForumPost<\/code> &ccedil;alıştırarak aynı anda model ve migration oluşturmanızı &ouml;neririz. Bu, migration dosyasını otomatik olarak oluşturur (bu durumda, &#39;forum_posts&#39; DB tablo adı i&ccedil;in).<\/p>\r\n\r\n<h2>Model &ouml;zellikleri<\/h2>\r\n\r\n<p>Bunlar k&uuml;&ccedil;&uuml;k harf olmalıdır, snake_case. Ayrıca, tablo s&uuml;tunu adlarıyla aynı kuralları izlemelidirler.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>$this-&gt;updated_at<\/code>,&nbsp;<code>$this-&gt;title<\/code>.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>$this-&gt;UpdatedAt<\/code>,&nbsp;<code>$this-&gt;blogTitle<\/code>.<\/p>\r\n\r\n<h2>Model Y&ouml;ntemleri<\/h2>\r\n\r\n<p>Laravel projelerindeki modellerinizdeki y&ouml;ntemler, Laravel projelerinizdeki t&uuml;m y&ouml;ntemler gibi ilk karakter k&uuml;&ccedil;&uuml;k harf olmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>public function get()<\/code>,&nbsp;<code>public function getAll()<\/code>.<\/p>\r\n\r\n<p>K&ouml;t&uuml; &ouml;rnekler: <code>public function GetPosts()<\/code>,&nbsp;<code>public function get_posts()<\/code>.<\/p>\r\n\r\n<h2>İlişkiler<\/h2>\r\n\r\n<ul>\r\n\t<li>\r\n\t<h3>hasOne veya belongsTo&nbsp;(one to many)<\/h3>\r\n\t<\/li>\r\n<\/ul>\r\n\r\n<p>Bunlar tekil formda olmalı ve normal model y&ouml;ntemlerle aynı adlandırma kurallarına uymalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>public function postAuthor()<\/code>,&nbsp;<code>public function phone()<\/code>.<\/p>\r\n\r\n<ul>\r\n\t<li>\r\n\t<h3>hasMany, belongsToMany, hasManyThrough (one to many)<\/h3>\r\n\t<\/li>\r\n<\/ul>\r\n\r\n<p>Bunlar bir&ccedil;ok adlandırma kuralınınkiyle aynı olmalıdır, ancak &ccedil;oğul olmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>public function comments()<\/code>,&nbsp;<code>public function roles()<\/code>.<\/p>\r\n\r\n<ul>\r\n\t<li>\r\n\t<h3>Polimorfik ilişkiler<\/h3>\r\n\t<\/li>\r\n<\/ul>\r\n\r\n<p>İsimlendirmeyi doğru yapmak i&ccedil;in bunlar biraz garip olabilir. İdeal olarak, b&ouml;yle bir y&ouml;nteme sahip olmak istersiniz:<\/p>\r\n\r\n<pre>\r\n<code class=\"language-php\">public function category(){\r\n    return $this-&gt;morphMany('App\\Category', 'categoryable');\r\n}<\/code><\/pre>\r\n\r\n<p>Laravel varsayılan olarak bir categoryable_id ve categoryable_type olduğunu varsayar.<\/p>\r\n\r\n<p>Ancak varsayılanları değiştirmek i&ccedil;in <code>morphMany<\/code>&nbsp; (<code>public function morphMany($related, $name, $type = null, $id = null, $localKey = null))<\/code> i&ccedil;in diğer isteğe bağlı parametreleri kullanabilirsiniz.<\/p>\r\n\r\n<h2>Controllerda isimlendirme<\/h2>\r\n\r\n<p>Bunlar model y&ouml;ntemleriyle aynı kurallara uymalıdır.&nbsp; Ayrıca, normal CRUD işlemleri i&ccedil;in, aşağıdaki y&ouml;ntem adlarından birini kullanmaları gerekir.<\/p>\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Verb<\/th>\r\n\t\t\t<th>URI<\/th>\r\n\t\t\t<th>Typical Method Name<\/th>\r\n\t\t\t<th>Route Name<\/th>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>GET<\/td>\r\n\t\t\t<td><code>\/photos<\/code><\/td>\r\n\t\t\t<td><code>index()<\/code><\/td>\r\n\t\t\t<td>photos.index<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>GET<\/td>\r\n\t\t\t<td><code>\/photos\/create<\/code><\/td>\r\n\t\t\t<td><code>create()<\/code><\/td>\r\n\t\t\t<td>photos.create<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>POST<\/td>\r\n\t\t\t<td><code>\/photos<\/code><\/td>\r\n\t\t\t<td><code>store()<\/code><\/td>\r\n\t\t\t<td>photos.store<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>GET<\/td>\r\n\t\t\t<td><code>\/photos\/{photo}<\/code><\/td>\r\n\t\t\t<td><code>show()<\/code><\/td>\r\n\t\t\t<td>photos.show<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>GET<\/td>\r\n\t\t\t<td><code>\/photos\/{photo}\/edit<\/code><\/td>\r\n\t\t\t<td><code>edit()<\/code><\/td>\r\n\t\t\t<td>photos.edit<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>PUT\/PATCH<\/td>\r\n\t\t\t<td><code>\/photos\/{photo}<\/code><\/td>\r\n\t\t\t<td><code>update()<\/code><\/td>\r\n\t\t\t<td>photos.update<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>DELETE<\/td>\r\n\t\t\t<td><code>\/photos\/{photo}<\/code><\/td>\r\n\t\t\t<td><code>destroy()<\/code><\/td>\r\n\t\t\t<td>photos.destroy<\/td>\r\n\t\t<\/tr>\r\n\t<\/thead>\r\n<\/table>\r\n\r\n<h2>Traits<\/h2>\r\n\r\n<p><span style=\"font-size:13px\">Traits <\/span>sıfat kelimeler olmalıdır.<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>Notifiable<\/code>,&nbsp;<code>Dispatchable<\/code>, etc.<\/p>\r\n\r\n<h2>Blade g&ouml;r&uuml;n&uuml;m dosyaları<\/h2>\r\n\r\n<p>Blade dosyaları k&uuml;&ccedil;&uuml;k harf olmalıdır, snake_case (kelimeler arasında alt &ccedil;izgi).<\/p>\r\n\r\n<p>&Ouml;rneğin: <code>all.blade.php<\/code>,&nbsp;<code>all_posts.blade.php<\/code>, etc<\/p>","kategori":"1cb9bb7ab9acda2d6cf92b33","tarih":"2020-01-13 15:04:38", "oneCikarilan": "1", "etiketler": "a,b,c,d,e,f,g"}
]